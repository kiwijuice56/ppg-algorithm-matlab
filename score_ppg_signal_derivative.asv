function [scores, second_pulse, derivative, systolic_peak, diastolic_peak, dicrotic_notch] = score_ppg_signal_derivative(processed_ppg_signal)
%SCORE_PPG_SIGNAL Returns the health scores of all pulses in a preprocessed
% PPG signal (via preprocess_ppg_signal(raw, timestamps)). Uses first
% derivative.
arguments
    processed_ppg_signal (1,:) double
end

% Split signal into pulses
[~, indices] = split_ppg_signal(processed_ppg_signal);

% Calculate scores of all pulses

scores = zeros(length(indices) - 1, 1);
for i=1:length(indices) - 1 
    [pulse, systolic_peak, diastolic_peak, dicrotic_notch] = find_pulse_points(processed_ppg_signal(indices(i) : indices(i + 1)));

    % peaks in the first derivative
    scores(i) = 0;
    if length(pulse_indices) > 1
        scores(i) = dy(pulse_indices(2));
    end

    if i == 4
        [~, pulse_indices] = findpeaks(pulse);

        % Case 0: very poor signal
        if isempty(pulse_indices)
            systolic_peak = 1;
            diastolic_peak = length(pulse);
        % Case 1: the notch is clearly visible
        elseif length(pulse_indices) > 1 
            systolic_peak = pulse_indices(1);
            diastolic_peak = pulse_indices(2);
        % Case 2: the notch is too flat, but systolic notch is there
        else
            systolic_peak = pulse_indices(1);
            peak_offset = min([20, length(pulse) - systolic_peak]); % Add a small offset so that we don't select the systolic peak again
            half_pulse_gradient = gradient(pulse(pulse_indices(1) + peak_offset : length(pulse)));
            [~, zero_crossing_index] = min(abs(half_pulse_gradient));
            diastolic_peak = pulse_indices(1) + peak_offset + zero_crossing_index - 1;
        end

        [~, dicrotic_notch] = min(pulse(systolic_peak : diastolic_peak));
        dicrotic_notch = systolic_peak + dicrotic_notch - 1;

        derivative = dy;
        second_pulse = pulse;
    end
end

end

